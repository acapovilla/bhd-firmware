/**
 * Basic SD card test
 *
 * Arduino Nano Every + MicroSD card breakout (DFR0229)
 *
 * Lib: adafruit/SdFat - Adafruit Fork @ 2.2.1
 *
 * Breakout working voltage = 5V
 * MISO -> D12 (CIPO SC1)
 * SCK  -> D13 (SCK)
 * SS   -> D10
 * MOSI -> D11 (COPI SC1)
 */

#include <Arduino.h>

// include the SD library:
#include <SPI.h>

#include "SdFat.h"

// SD_FAT_TYPE = 0 for SdFat/File as defined in SdFatConfig.h,
// 1 for FAT16/FAT32, 2 for exFAT, 3 for FAT16/FAT32 and exFAT.
#define SD_FAT_TYPE 3
// Set DISABLE_CHIP_SELECT to disable a second SPI device.
// For example, with the Ethernet shield, set DISABLE_CHIP_SELECT
// to 10 to disable the Ethernet controller.
const int8_t DISABLE_CS_PIN = -1;
// Test with reduced SPI speed for breadboards.  SD_SCK_MHZ(4) will select
// the highest speed supported by the board that is not over 4 MHz.
// Change SPI_SPEED to SD_SCK_MHZ(50) for best performance.
#define SPI_SPEED SD_SCK_MHZ(4)

#ifndef SDCARD_SS_PIN
const uint8_t SD_CS_PIN = 10;
#else    // SDCARD_SS_PIN
const uint8_t SD_CS_PIN = 10;
#endif   // SDCARD_SS_PIN

// Try to select the best SD card configuration.
#if HAS_SDIO_CLASS
#define SD_CONFIG SdioConfig(FIFO_SDIO)
#elif ENABLE_DEDICATED_SPI
#define SD_CONFIG SdSpiConfig(SD_CS_PIN, DEDICATED_SPI, SPI_SPEED)
#else   // HAS_SDIO_CLASS
#define SD_CONFIG SdSpiConfig(SD_CS_PIN, SHARED_SPI, SD_SCK_MHZ(16))
#endif   // HAS_SDIO_CLASS

// SD card chip select
int chipSelect = 10;

SdFs sd;
cid_t m_cid;
csd_t m_csd;
uint32_t m_eraseSize;
uint32_t m_ocr;

bool failFlag = false;

void printConfig(SdSpiConfig config) {
    if (DISABLE_CS_PIN < 0) {
        Serial.print(
            F("\nAssuming the SD is the only SPI device.\n"
              "Edit DISABLE_CS_PIN to disable an SPI device.\n"));
    } else {
        Serial.print(F("\nDisabling SPI device on pin "));
        Serial.println(int(DISABLE_CS_PIN));
        pinMode(DISABLE_CS_PIN, OUTPUT);
        digitalWrite(DISABLE_CS_PIN, HIGH);
    }
    Serial.print(F("\nAssuming the SD chip select pin is: "));
    Serial.println(int(config.csPin));
    Serial.print(F("\nEdit SD_CS_PIN to change the SD chip select pin.\n"));
}

void setup() {
    // put your setup code here, to run once:
    // pinMode(ORANGELED, OUTPUT);
    // digitalWrite(ORANGELED, LOW);   // set low to turn OFF

    Serial.begin(115200);
    while (!Serial)
        ;   // wait for serial port to connect. Needed for native USB

    delay(100);
    Serial.print(F("SdFat version: "));
    Serial.println(SD_FAT_VERSION_STR);
    printConfig(SD_CONFIG);

    Serial.print("\nInitializing SD card...");

    // Serial.print(F("\nSPI pins:\n"));
    // Serial.print(F("MISO: "));
    // Serial.println(int(MISO));
    // Serial.print(F("MOSI: "));
    // Serial.println(int(MOSI));
    // Serial.print(F("SCK:  "));
    // Serial.println(int(SCK));
    // Serial.print(F("SS:   "));
    // Serial.println(int(SS));

    uint32_t t = millis();
    if (!sd.cardBegin(SD_CONFIG)) {
        Serial.print(
            F("\nSD initialization failed.\n"
              "Do not reformat the card!\n"
              "Is the card correctly inserted?\n"
              "Is there a wiring/soldering problem?\n"));
        if (isSpi(SD_CONFIG)) {
            Serial.print(
                F("Is SD_CS_PIN set to the correct value?\n"
                  "Does another SPI device need to be disabled?\n"));
        }
        if (sd.sdErrorCode()) {
            Serial.print(F("SD errorCode: "));
            printSdErrorSymbol(&Serial, sd.sdErrorCode());
            Serial.print(F(" = 0x"));
            Serial.println(int(sd.sdErrorCode()));
            Serial.print(F("SD errorData = 0x"));
            Serial.println(int(sd.sdErrorData()));
        }
        while (1) delay(10);
    }
    t = millis() - t;
    Serial.print(F("init time: "));
    Serial.print(t);
    Serial.println(" ms");

    if (!sd.card()->readCID(&m_cid) || !sd.card()->readCSD(&m_csd) || !sd.card()->readOCR(&m_ocr)) {
        Serial.print(F("readInfo failed\n"));
    } else {
        // printCardType();
        Serial.print(F("\nCard type: "));
        switch (sd.card()->type()) {
            case SD_CARD_TYPE_SD1:
                Serial.print(F("SD1\n"));
                break;

            case SD_CARD_TYPE_SD2:
                Serial.print(F("SD2\n"));
                break;

            case SD_CARD_TYPE_SDHC:
                // if (sdCardCapacity(&m_csd) < 70000000) {
                //     cout << F("SDHC\n");
                // } else {
                //     cout << F("SDXC\n");
                // }
                Serial.print(F("SDHC or SDXC\n"));
                break;

            default:
                Serial.print(F("Unknown\n"));
        }

        // cidDmp();
        Serial.print(F("\nManufacturer ID: "));
        Serial.println(int(m_cid.mid), HEX);
        Serial.print(F("OEM ID: "));
        Serial.print(m_cid.oid[0]);
        Serial.println(m_cid.oid[1]);
        Serial.print(F("Product: "));
        for (uint8_t i = 0; i < 5; i++) {
            Serial.print(m_cid.pnm[i]);
        }
        Serial.println();
        // Serial.print(F("\nVersion: "));
        // Serial.print(int(m_cid.prv_n));
        // Serial.print('.');
        // Serial.println(int(m_cid.prv_m));
        // Serial.print(F("Serial number: "));
        // Serial.println(m_cid.psn, HEX);
        // Serial.print(F("Manufacturing date: "));
        // Serial.print(int(m_cid.mdt_month));
        // Serial.print('/');
        // Serial.print((2000 + m_cid.mdt_year_low + 10 * m_cid.mdt_year_high) << endl);
        // Serial.println();

        // csdDmp();
    }
}

void loop() {}
